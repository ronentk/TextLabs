# lab_container
type lc : c {
    predicates {

		potential(mx, lc);
		component(m, mx);
		result_new(m, lc);

    }

	rules {
		# dissallowed solid mix though allowed in i7
		mix/el :: $at(P, r) & $at(lc, r) & $open(lc) & potential(mx, lc) & in(m, I) & $liquid(m) -> in(mx, lc) & liquid(mx) & result_new(mx, lc) & component(m, mx);
		mix/ep :: $at(P, r) & $at(lc, r) & in(m, I) & $open(lc) & potential(mx, lc) & $powder(m) -> in(mx, lc) & powder(mx) & result_new(mx, lc) & component(m, mx);
		mix/l :: $at(P, r) & $at(lc, r) & $open(lc) & $in(mx, lc) & in(m, I) & $liquid(m) & $liquid(mx) -> result_new(mx, lc) & component(m, mx);
		mix/lp :: $at(P, r) & $at(lc, r) & $open(lc) & $in(mx, lc) & in(m, I) & $liquid(m) & powder(mx) -> liquid(mx) & result_new(mx, lc) & component(m, mx);
		mix/p :: $at(P, r) & $at(lc, r) & $in(mx, lc) & in(m, I) & $open(lc) & $powder(m) & $powder(mx) -> result_new(mx, lc) & component(m, mx);
		mix/pl :: $at(P, r) & $at(lc, r) & $in(mx, lc) & in(m, I) & $open(lc) & $powder(m) & liquid(mx) -> powder(mx) & result_new(mx, lc) & component(m, mx);


    }

	constraints {
    }

	reverse_rules {
    }

    inform7 {
        type {
            kind :: "lab_container";
            definition :: "Lab_containers are portable and openable. A lab_container can be sealed or unsealed. A lab_container is usually unsealed. An sa_potential is a kind of container. An sa_potential is unopenable. One sa_potential is part of every lab_container.";
        }

        predicates {
			sealed(lc) :: "The {lc} is sealed";
			potential(mx, lc) :: "In the {lc}'s sa_potential is a {mx}";
			component(m, mx) :: "The {m} is in {mx}'s composition";
			result_new(m, lc) :: "The {lc} has produced the {m}";
        }

		commands {

			mix/l :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
			mix/p :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
			mix/el :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
			mix/ep :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
			mix/pl :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
			mix/lp :: "mix {m} into {lc}" :: "mixing the {m} into the {lc}";
        }

        code ::
        """
		Mixing it into is an action applying to one carried thing and one touchable thing.
		Understand "mix [material] into [thing]" as mixing it into.
		Understand "put [material] into [lab_container]" as mixing it into.
		Understand "insert [material] into [lab_container]" as mixing it into.

		Check inserting a thing into something when the second noun is a lab_container:
			unless the thing is a material:
				say "You can only put materials into a lab_container." instead.

		Check mixing a material into something when the second noun is not a lab_container:
			unless the second noun is a material:
				say "You can only mix [the noun] into a lab_container." instead.

		Check mixing a material into something when the second noun is not open:
			unless the second noun is a material:
				say "You can only mix into open containers." instead.

		[To enable single-argument actions for MVP version, this is a hack assuming only one
		lab_container]
		Check mixing a material into something when the second noun is a material:
			let L be a random lab_container;
			unless L is nothing:
				try mixing the noun into the L instead;

		Check mixing a material into something when the second noun is a lab_container:
			[If the container has one mixture: continue]
			unless the second noun contains exactly one mixture:
				[If the container doesn't contain a mixture already, check that it can be used- it must be empty and we still haven't passed the max. number of uses ]
				if the second noun is empty:
					let the current sa_potential be a random sa_potential which is part of the second noun;
					if the current sa_potential is empty:
						say "You have passed the maximum number of uses for the lab_container." instead.


		[Always have at most one mixture in a lab container, which is in the state of the last thing mixed in it]
		Carry out mixing:
			if the second noun contains nothing:
				let the current sa_potential be a random sa_potential which is part of the second noun;
				let M be the first thing held by the current sa_potential;
				now M is in the second noun;
			let M be the first thing held by the second noun;
			let S be the state of the noun;
			if the M provides the property state:
				now the state of M is S;
			let C be a random composition which is part of M;
			unless C is nothing:
				now the noun is in C;
				now the second noun has produced M;

		Report mixing:
			say "Mixed!"
        """;

    }
}
